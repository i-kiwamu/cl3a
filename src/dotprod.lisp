(in-package :cl-user)
(defpackage cl3a.dotprod
  (:use :cl :sb-ext :sb-c :alexandria :cl3a.utilities :cl3a.dotprod_vop)
  (:export :sv*v :dv*v))
(in-package :cl3a.dotprod)


(eval-when (:compile-toplevel :load-toplevel :execute)
  (defconstant +unroll/2+ (the fixnum 4)))


;; (defmacro v*v-ker (eltype s n nc va vb)
;;   "Dot production between vectors va and vb"
;;   (let ((i-list (make-gensym-list +unroll+ "i")))
;;     (with-gensyms (iend iend0 res i)
;;       `(let* ((,iend (min ,nc (the fixnum (+ ,s ,n))))
;;               (,iend0 (min-factor ,iend +unroll+))
;;               (,res (coerce 0.0 ',eltype)))
;;          (declare (type fixnum ,iend0)
;;                   (type ,eltype ,res))
;;          ;; Do NOT use dotimes-unroll macro for speed
;;          (do (,@(loop :for ui :below +unroll+
;;                    :for ii :in i-list
;;                    :append `((,ii (the fixnum (+ ,s ,ui))
;;                                   (the fixnum (+ ,ii +unroll+))))))
;;              ((>= ,(car i-list) ,iend0))
;;            (incf ,res
;;                  (+ ,@(loop :for ii :in i-list
;;                          :append `((* (aref ,va ,ii) (aref ,vb ,ii)))))))
;;          ;; if nv < unroll or maxi < iend, calculate the rest of elements
;;          (do ((,i ,iend0 (1+ ,i)))
;;              ((>= ,i ,iend) ,res)
;;            (incf ,res (* (aref ,va ,i) (aref ,vb ,i))))))))


;; (defmacro v*v (eltype va vb)
;;   (with-gensyms (calc na nb nc)
;;     `(flet ((,calc (s n nc va vb)
;;               (declare (optimize (speed 3) (debug 0) (safety 0))
;;                        (type fixnum s n nc)
;;                        (type (simple-array ,eltype (*)) va vb))
;;               ;; (v*v-ker ,eltype s n nc va vb)))
;;               (dv*v-ker s n nc va vb)))
;;        (declare (inline ,calc))
;;        (let* ((,na (length ,va))
;;               (,nb (length ,vb))
;;               ;; (,nc (cond ((/= ,na ,nb) (different-length-warn ,na ,nb)
;;               ;;                          (min ,na ,nb))
;;               ;;            (t ,na)))
;;               (,nc (min ,na ,nb))
;;               ;; (,tbl (type-byte-length ',eltype))
;;               ;; (,m (ifloor +L1-size+ ,tbl))
;;               ;; (,res (coerce 0.0 ',eltype)))
;;               )
;;          (declare (type fixnum ,na ,nb ,nc))
;;                   ;; (type ,eltype ,res))
;;          (,calc 0 ,nc ,nc ,va ,vb)))))
;;          ;; (dotimes-interval (,i ,m ,nc)
;;          ;;   (incf ,res (,calc ,i ,m ,nc ,va ,vb)))
;;          ;; ,res))))


(declaim (ftype (function ((simple-array double-float (*))
                           (simple-array double-float (*)))
                          double-float)
                dv*v))
(defun dv*v (va vb)
  "Dot product with two double-float vectors va and vb"
  (declare (optimize (speed 3) (safety 0))
           (type (simple-array double-float (*)) va vb))
  ;; (v*v double-float va vb))
  (let* ((n (min (length va) (length vb)))
         (n0 (min-factor n +unroll+))
         (res-pd (setzero-pd))
         (res 0d0))
    (declare (type fixnum n n0)
             (type (simd-pack double-float) res-pd)
             (type double-float res))
    (do ((i 0 (+ i +unroll+)))
        ((>= i n0))
      (setf res-pd
            (f2+-pd res-pd (dpi4-pd va vb i))))
    (multiple-value-bind (lo hi)
        (%simd-pack-doubles res-pd)
      (declare (type double-float lo hi))
      (incf res (+ lo hi)))
    (do ((i n0 (1+ i)))
        ((>= i n) res)
      (incf res (* (aref va i) (aref vb i))))))


(declaim (ftype (function ((simple-array single-float (*))
                           (simple-array single-float (*)))
                          single-float)
                sv*v))
(defun sv*v (va vb)
  "Dot product with two single-float vectors va and vb"
  (declare (optimize (speed 3) (safety 0))
           (type (simple-array single-float (*)) va vb))
  (let* ((n (min (length va) (length vb)))
         (n0 (min-factor n +unroll+))
         (res-ps (setzero-ps))
         (res 0s0))
    (declare (type fixnum n n0)
             (type (simd-pack single-float) res-ps)
             (type single-float res))
    (do ((i 0 (+ i +unroll+)))
        ((>= i n0))
      (setf res-ps
            (f4+-ps res-ps (dpi2-ps va vb i))))
    (multiple-value-bind (r0 r1 r2 r3)
        (%simd-pack-singles res-ps)
      (declare (type single-float r0 r1 r2 r3))
      (incf res (+ r0 r1 r2 r3)))
    (do ((i n0 (1+ i)))
        ((>= i n) res)
      (incf res (* (aref va i) (aref vb i))))))
