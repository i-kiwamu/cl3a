(in-package :cl-user)
(defpackage cl3a.rotate
  (:use :cl :alexandria :trivial-types)
  (:shadowing-import-from :trivial-types
                          :proper-list
                          :proper-list-p
                          :string-designator)
  (:import-from :cl3a.utilities
                :min-factor
                :dvvv2-calc-within-L1
                :lvvv2-calc-within-L1
                :different-length-warn)
  (:export :drotate :lrotate))
(in-package :cl3a.rotate)


(defmacro rotate-ker (val-type p n nv va vb c s)
  "Rotate two vectors (va & vb) with cos and sin,
   and return new two vectors"
  (with-gensyms (nvec n5 res1 res2 i maxi i1 i2 i3 i4)
    `(let* ((,nvec (min ,nv (the fixnum (+ ,p ,n))))
            (,n5 (min-factor ,nvec 5))
            (,res1 (make-array (list ,nvec) :element-type (quote ,val-type)))
            (,res2 (make-array (list ,nvec) :element-type (quote ,val-type))))
       (declare (type fixnum ,nvec ,n5)
                (type (simple-array ,val-type (*)) ,res1 ,res2))
       (cond
         ((or (>= ,p ,nv) (< ,p 0) (< ,nvec 0))
          (warn (format nil "Position ~D is out of range of vectors with length of ~D." ,p ,nvec)))
         ((< ,nvec 5) (do ((,i ,p (+ ,i 1)))
                          ((>= ,i ,nvec))
                        (setf (aref ,res1 ,i) (+ (* ,c (aref ,va ,i))
                                                 (* ,s (aref ,vb ,i))))
                        (setf (aref ,res2 ,i) (- (* ,c (aref ,vb ,i))
                                                 (* ,s (aref ,va ,i))))))
         (t (let ((,maxi
                   (do ((,i ,p (+ ,i 5))
                        (,i1 (the fixnum (+ ,p 1)) (the fixnum (+ ,i1 5)))
                        (,i2 (the fixnum (+ ,p 2)) (the fixnum (+ ,i2 5)))
                        (,i3 (the fixnum (+ ,p 3)) (the fixnum (+ ,i3 5)))
                        (,i4 (the fixnum (+ ,p 4)) (the fixnum (+ ,i4 5))))
                       ((>= ,i ,n5) ,i)
                     (setf (aref ,res1 ,i) (+ (* ,c (aref ,va ,i))
                                              (* ,s (aref ,vb ,i))))
                     (setf (aref ,res2 ,i) (- (* ,c (aref ,vb ,i))
                                              (* ,s (aref ,va ,i))))
                     (setf (aref ,res1 ,i1) (+ (* ,c (aref ,va ,i1))
                                               (* ,s (aref ,vb ,i1))))
                     (setf (aref ,res2 ,i1) (- (* ,c (aref ,vb ,i1))
                                               (* ,s (aref ,va ,i1))))
                     (setf (aref ,res1 ,i2) (+ (* ,c (aref ,va ,i2))
                                               (* ,s (aref ,vb ,i2))))
                     (setf (aref ,res2 ,i2) (- (* ,c (aref ,vb ,i2))
                                               (* ,s (aref ,va ,i2))))
                     (setf (aref ,res1 ,i3) (+ (* ,c (aref ,va ,i3))
                                               (* ,s (aref ,vb ,i3))))
                     (setf (aref ,res2 ,i3) (- (* ,c (aref ,vb ,i3))
                                               (* ,s (aref ,va ,i3))))
                     (setf (aref ,res1 ,i4) (+ (* ,c (aref ,va ,i4))
                                               (* ,s (aref ,vb ,i4))))
                     (setf (aref ,res2 ,i4) (- (* ,c (aref ,vb ,i4))
                                               (* ,s (aref ,va ,i4)))))))
              (declare (type fixnum ,maxi))
              (when (< ,maxi ,nvec)
                (do ((,i ,maxi (+ ,i 1)))
                    ((>= ,i ,nvec))
                  (setf (aref ,res1 ,i) (+ (* ,c (aref ,va ,i))
                                           (* ,s (aref ,vb ,i))))
                  (setf (aref ,res2 ,i) (- (* ,c (aref ,vb ,i))
                                           (* ,s (aref ,va ,i)))))))))
       (values ,res1 ,res2))))


(declaim (inline drotate-ker)
         (ftype (function (fixnum fixnum fixnum
                           (simple-array double-float (*))
                           (simple-array double-float (*))
                           (double-float -1d0 1d0) (double-float -1d0 1d0))
                          (values (simple-array double-float (*))
                                  (simple-array double-float (*))))
                drotate-ker))
(defun drotate-ker (p n nv va vb c s)
  "Rotate two double-float vectors (va & vb) with cos and sin,
   and return new two vectors"
  (declare (optimize (speed 3) (debug 0) (safety 0))
           (type fixnum p n nv)
           (type (simple-array double-float (*)) va vb)
           (type double-float c s))
  (rotate-ker double-float p n nv va vb c s))


(declaim (inline lrotate-ker)
         (ftype (function (fixnum fixnum fixnum
                           (simple-array long-float (*))
                           (simple-array long-float (*))
                           (long-float -1l0 1l0) (long-float -1l0 1l0))
                          (values (simple-array long-float (*))
                                  (simple-array long-float (*))))
                lrotate-ker))
(defun lrotate-ker (p n nv va vb c s)
  "Rotate two long-float vectors (va & vb) with cos and sin,
   and return new two vectors"
  (declare (optimize (speed 3) (debug 0) (safety 0))
           (type fixnum p n nv)
           (type (simple-array long-float (*)) va vb)
           (type long-float c s))
  (rotate-ker long-float p n nv va vb c s))


(declaim (ftype (function ((simple-array double-float (*))
                           (simple-array double-float (*))
                           (double-float -1d0 1d0) (double-float -1d0 1d0))
                          (values (simple-array double-float (*))
                                  (simple-array double-float (*))))
                drotate))
(defun drotate (va vb c s)
  "Rotate two double-float vectors (va & vb) with cos and sin,
   and return new two vectors"
  (declare (optimize (speed 3))
           (type (simple-array double-float (*)) va vb)
           (type (double-float 0d0 1d0) c s))
  (let* ((na (length va))
         (nb (length vb))
         (nv (cond ((/= na nb) (different-length-warn na nb)
                               (min na nb))
                   (t na)))
         (vc (make-array (list nv) :element-type 'double-float))
         (vd (make-array (list nv) :element-type 'double-float))
         (p 0))
    (declare (type fixnum na nb nv p)
             (type (simple-array double-float (*)) vc vd))
    (multiple-value-bind (res1 res2)
        (dvvv2-calc-within-L1 #'drotate-ker nv va vb c s)
      (declare (type (proper-list (simple-array double-float (*))) res1 res2))
      (let ((nres (length res1)))
        (declare (type fixnum nres))
        (dotimes (ir nres)
          (let* ((r1 (nth ir res1))
                 (r2 (nth ir res2))
                 (nr (length r1)))
            (declare (type (simple-array double-float (*)) r1 r2)
                     (type fixnum nr))
            (setf (subseq vc p (+ p nr)) r1)
            (setf (subseq vd p (+ p nr)) r2)
            (incf p nr)))))
    (values vc vd)))


(declaim (ftype (function ((simple-array long-float (*))
                           (simple-array long-float (*))
                           (long-float -1l0 1l0) (long-float -1l0 1l0))
                          (values (simple-array long-float (*))
                                  (simple-array long-float (*))))
                lrotate))
(defun lrotate (va vb c s)
  "Rotate two long-float vectors (va & vb) with cos and sin,
   and return new two vectors"
  (declare (optimize (speed 3))
           (type (simple-array long-float (*)) va vb)
           (type (long-float 0l0 1l0) c s))
  (let* ((na (length va))
         (nb (length vb))
         (nv (cond ((/= na nb) (different-length-warn na nb)
                               (min na nb))
                   (t na)))
         (vc (make-array (list nv) :element-type 'long-float))
         (vd (make-array (list nv) :element-type 'long-float))
         (p 0))
    (declare (type fixnum na nb nv p)
             (type (simple-array long-float (*)) vc vd))
    (multiple-value-bind (res1 res2)
        (lvvv2-calc-within-L1 #'drotate-ker nv va vb c s)
      (declare (type (proper-list (simple-array long-float (*))) res1 res2))
      (let ((nres (length res1)))
        (declare (type fixnum nres))
        (dotimes (ir nres)
          (let* ((r1 (nth ir res1))
                 (r2 (nth ir res2))
                 (nr (length r1)))
            (declare (type (simple-array long-float (*)) r1 r2)
                     (type fixnum nr))
            (setf (subseq vc p (+ p nr)) r1)
            (setf (subseq vd p (+ p nr)) r2)
            (incf p nr)))))
    (values vc vd)))
