(in-package :cl-user)
(defpackage cl3a.transpose
  (:use :cl :alexandria)
  (:export :tpose/double-float :tpose/long-float))
(in-package :cl3a.transpose)


(declaim (ftype (function ((simple-array double-float (* *)))
                          (simple-array double-float (* *)))
                tpose/double-float))
(defun tpose/double-float (ma)
  (declare (optimize (speed 3) (safety 0))
           (type (simple-array double-float (* *)) ma))
  (let* ((nr (array-dimension ma 0))
         (nc (array-dimension ma 1))
         (nrc (array-total-size ma))
         (mat (make-array (list nc nr) :element-type 'double-float)))
       (declare (type fixnum nr nc nrc)
                (type (simple-array double-float (* *)) mat))
       ;; initialize
       (dotimes (rma nrc)
         (setf (row-major-aref mat rma)
               (row-major-aref ma rma)))
       (labels
           ((rc (n)
              (declare (type fixnum n))
              (let* ((r (mod n nr))
                     (b (* r nc))
                     (n0 (multiple-value-bind (q)
                             (floor n nr) q)))
                (declare (type fixnum r b n0))
                (the fixnum (+ b n0))))
            (inext (i n i0)
              (declare (type fixnum i n i0))
              (let ((i2 (1+ i))
                    (n2 (rc n)))
                (declare (type fixnum i2 n2))
                (if (<= n2 i0) (values i2 n2) (inext i2 n2 i0)))))
         (dotimes (rma nrc)
           (block continue
             (multiple-value-bind (i next)
                 (inext 0 rma rma)
               (when (or (< next rma) (= i 1))
                 (return-from continue))
               (setf next rma)
               (loop :with tmp :of-type double-float
                     = (row-major-aref mat rma)
                  :do
                  (setf i (rc next))
                  (setf (row-major-aref mat next)
                        (if (= i rma) tmp (row-major-aref mat i)))
                  (setf next i)
                  :while (> next rma))))))
       mat))


(declaim (ftype (function ((simple-array double-float (* *)))
                          (simple-array double-float (* *)))
                tpose/long-float))
(defun tpose/long-float (ma)
  (declare (optimize (speed 3) (safety 0))
           (type (simple-array long-float (* *)) ma))
  (let* ((nr (array-dimension ma 0))
         (nc (array-dimension ma 1))
         (nrc (array-total-size ma))
         (mat (make-array (list nc nr) :element-type 'long-float)))
       (declare (type fixnum nr nc nrc)
                (type (simple-array long-float (* *)) mat))
       ;; initialize
       (dotimes (rma nrc)
         (setf (row-major-aref mat rma)
               (row-major-aref ma rma)))
       (labels
           ((rc (n)
              (declare (type fixnum n))
              (let* ((r (mod n nr))
                     (b (* r nc))
                     (n0 (multiple-value-bind (q)
                             (floor n nr) q)))
                (declare (type fixnum r b n0))
                (the fixnum (+ b n0))))
            (inext (i n i0)
              (declare (type fixnum i n i0))
              (let ((i2 (1+ i))
                    (n2 (rc n)))
                (declare (type fixnum i2 n2))
                (if (<= n2 i0) (values i2 n2) (inext i2 n2 i0)))))
         (dotimes (rma nrc)
           (block continue
             (multiple-value-bind (i next)
                 (inext 0 rma rma)
               (when (or (< next rma) (= i 1))
                 (return-from continue))
               (setf next rma)
               (loop :with tmp :of-type long-float
                     = (row-major-aref mat rma)
                  :do
                  (setf i (rc next))
                  (setf (row-major-aref mat next)
                        (if (= i rma) tmp (row-major-aref mat i)))
                  (setf next i)
                  :while (> next rma))))))
       mat))
