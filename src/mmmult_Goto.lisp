(in-package :cl-user)
(defpackage cl3a.mmmult_Goto
  (:use :cl :alexandria :cl3a.utilities)
  (:export :gemm-kernel :gemm1 :dm*m))
(in-package :cl3a.mmmult_Goto)


(declaim (ftype (function ((simple-array double-float (* *))
                           fixnum fixnum fixnum fixnum)
                          (simple-array double-float (* *)))
                submatrix))
         ; (inline submatrix))
(defun submatrix (X si sj ni nj)
  "take sub-matrix of X from (si sj) with length of (ni nj)"
  (declare (type (simple-array double-float (* *)) X)
           (type fixnum si sj ni nj))
           ; (optimize (speed 3) (safety 0)))
  (let* ((ei (min (array-dimension X 0)
                  (+ si ni)))
         (ej (min (array-dimension X 1)
                  (+ sj nj)))
         (nr (- ei si))
         (nc (- ej sj))
         (res (make-array (list nr nc) :element-type 'double-float)))
    (declare (type fixnum ei ej nr nc)
             (type (simple-array double-float (* *)) res))
    (dotimes (i nr)
      (dotimes (j nc)
        (setf (aref res i j)
              (aref X (+ i si) (+ j sj)))))
    res))


(declaim (ftype (function ((simple-array double-float (* *)) fixnum)
                          (cons (simple-array double-float (* *)) t))
                hpack-matrix))
         ; (inline hpack-matrix))
(defun hpack-matrix (X width)
  "pack matrix X to horizontal direction with width"
  (declare (type (simple-array double-float (* *)) X)
           (type fixnum width))
           ; (optimize (speed 3) (safety 0)))
  (let ((nxr (array-dimension X 0))
        (nxc (array-dimension X 1))
        (res '()))
    (declare (type fixnum nxr nxc))
    (dotimes-interval2 (jj 0 nxc) (w width)
      (setf res
            (append res (list (submatrix X 0 jj nxr width)))))
    res))


(declaim (ftype (function ((simple-array double-float (* *)) fixnum)
                          (cons (simple-array double-float (* *)) t))
                vpack-matrix))
         ; (inline vpack-matrix))
(defun vpack-matrix (X height)
  "pack matrix X to vertical direction with height"
  (declare (type (simple-array double-float (* *)) X)
           (type fixnum height))
           ; (optimize (speed 3) (safety 0)))
  (let ((nxr (array-dimension X 0))
        (nxc (array-dimension X 1))
        (res '()))
    (declare (type fixnum nxr nxc))
    (dotimes-interval2 (ii 0 nxr) (h height)
      (setf res
            (append res (list (submatrix X ii 0 h nxc)))))
    res))


(declaim (ftype (function (fixnum fixnum fixnum
                           (simple-array double-float (* *))
                           (simple-array double-float (* *))
                           (simple-array double-float (* *))))
                gemm-kernel))
         ; (inline gemm-kernel))
(defun gemm-kernel (m k n A B C)
  (declare (type fixnum m k n)
           (type (simple-array double-float (* *)) A B C))
           ; (optimize (speed 3) (safety 0)))
  (let* ((ms (min m (array-dimension A 0) (array-dimension C 0)))
         (ks (min k (array-dimension A 1) (array-dimension B 0)))
         (ns (min n (array-dimension B 1) (array-dimension C 1)))
         (n0 (min-factor ns 4))
         (maxj 0))
    (declare (type fixnum ms ks ns n0 maxj))
    (dotimes (i ms)
      (dotimes (p ks)
        (let ((maip (aref A i p))
              (ib (array-row-major-index B p 0))
              (ic (array-row-major-index C i 0)))
          (declare (type double-float maip)
                   (type fixnum ib ic))
          (setf maxj
                (do ((j 0 (+ j 4)))
                    ((>= j n0) j)
                  (incf (row-major-aref C ic)
                        (* maip (row-major-aref B ib)))
                  (incf ib)
                  (incf ic)
                  (incf (row-major-aref C ic)
                        (* maip (row-major-aref B ib)))
                  (incf ib)
                  (incf ic)
                  (incf (row-major-aref C ic)
                        (* maip (row-major-aref B ib)))
                  (incf ib)
                  (incf ic)
                  (incf (row-major-aref C ic)
                        (* maip (row-major-aref B ib)))
                  (incf ib)
                  (incf ic)))
          (do ((j maxj (1+ j)))
              ((>= j ns))
            (incf (row-major-aref C ic)
                  (* maip (row-major-aref B ib)))
            (incf ib)
            (incf ic)))))))


(declaim (ftype (function (fixnum fixnum fixnum
                           (simple-array double-float (* *))
                           (simple-array double-float (* *))
                           (simple-array double-float (* *))))
                gemm1))
(defun gemm1 (mc kc nr A B C)
  (declare (type fixnum mc kc nr)
           (type (simple-array double-float (* *)) A B C))
           ; (optimize (speed 3) (safety 0)))
  (let* ((m (min (array-dimension A 0)
                 (array-dimension C 0)))
         (k (min (array-dimension A 1)
                 (array-dimension B 0)))
         (n (min (array-dimension B 1)
                 (array-dimension C 1)))
         (Ap (make-array (list m (min kc k))
                         :element-type 'double-float))
         (Bp (make-array (list (min kc k) n)
                         :element-type 'double-float))
         (Caux (make-array (list mc nr) :element-type 'double-float)))
    (declare (type fixnum m k n)
             (type (simple-array double-float (* *)) Ap Bp Caux))
    (dotimes-interval2 (p 0 k) (t2 kc)
      (copy-matrix A 0 m p t2 Ap)
      (copy-matrix B p t2 0 n Bp)
      (let ((Ap-tildes (vpack-matrix Ap mc))
            (Bp-tildes (hpack-matrix Bp nr))
            (i 0))
        (declare (type fixnum i))
        (dolist (Apt Ap-tildes)
          (declare (type (simple-array double-float (* *)) Apt))
          (let ((t1 (array-dimension Apt 0))
                (j 0))
            (declare (type fixnum t1 j))
            (dolist (Bpt Bp-tildes)
              (declare (type (simple-array double-float (* *)) Bpt))
              (let ((t3 (array-dimension Bpt 1)))
                (declare (type fixnum t3))
                (gemm-kernel t1 t2 t3 Apt Bpt Caux)
                (dotimes (ii t1)
                  (dotimes (jj t3)
                    (incf (aref C (+ i ii) (+ j jj))
                          (aref Caux ii jj))
                    (setf (aref Caux ii jj) 0d0)))
                (incf j t3)))
            (incf i t1)))))))
        ;; (dotimes-interval2 (i 0 m) (t1 mc)
        ;;   (let ((Apt (car Ap-tildes)))
        ;;     (declare (type (simple-array double-float (* *)) Apt))
        ;;     (dotimes-interval2 (j 0 n) (t3 nr)
        ;;       (let ((Bpt (car Bp-tildes)))
        ;;         (declare (type (simple-array double-float (* *)) Bpt))
        ;;         (gemm-kernel t1 t2 t3 Apt Bpt Caux)
        ;;         (dotimes (ii t1)
        ;;           (dotimes (jj t3)
        ;;             (incf (aref C (+ i ii) (+ j jj))
        ;;                   (aref Caux ii jj))
        ;;             (setf (aref Caux ii jj) 0d0)))
        ;;         (setf Bp-tildes (cdr Bp-tildes))))
        ;;     (setf Ap-tildes (cdr Ap-tildes))))))))


(declaim (ftype (function ((simple-array double-float (* *))
                           (simple-array double-float (* *))
                           (simple-array double-float (* *))))
                dm*m))
(defun dm*m (A B C)
  (declare (type (simple-array double-float (* *)) A B C))
           ; (optimize (speed 3) (safety 0)))
  ; (gemm1 512 256 4 A B C))
  (gemm1 512 256 4 A B C))

