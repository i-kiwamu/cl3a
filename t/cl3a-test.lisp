(in-package :cl-user)
(defpackage cl3a-test
  (:use :cl :prove :cl3a :naive))
(in-package #:cl3a-test)


(defun ddotprod-test (n)
  (declare (type integer n))
  (let ((va (make-array n :element-type 'double-float))
        (vb (make-array n :element-type 'double-float)))
    (declare (type (simple-array double-float (*)) va vb))
    (dotimes (i n)
      (setf (aref va i) (random 1d0))
      (setf (aref vb i) (random 1d0)))
    (let ((res1 (coerce (dv*v va vb) 'single-float))
          (res2 (coerce (dv*v-naive va vb) 'single-float)))
      (= res1 res2))))


(defun dnorm-test (n)
  (declare (type integer n))
  (let ((va (make-array n :element-type 'double-float)))
    (declare (type (simple-array double-float (*)) va))
    (dotimes (i n)
      (setf (aref va i) (random 1d0)))
    (let ((res1 (coerce (dnorm va) 'single-float))
          (res2 (coerce (dnorm-naive va) 'single-float)))
      (= res1 res2))))


(defun dadd-test (n)
  (declare (type integer n))
  (let ((va (make-array n :element-type 'double-float))
        (vb (make-array n :element-type 'double-float))
        (a (random 1d0))
        (b (random 1d0))
        (res1 (make-array n :element-type 'double-float))
        (res2 (make-array n :element-type 'double-float))
        (test t))
    (declare (type (simple-array double-float (*)) va vb res1 res2)
             (type double-float a b)
             (type boolean test))
    (dotimes (i n)
      (setf (aref va i) (random 1d0))
      (setf (aref vb i) (random 1d0)))
    (block check
      (dv+v a va b vb res1)
      (dv+v-naive a va b vb res2)
      (dotimes (i n)
        (let ((r1 (coerce (aref res1 i) 'single-float))
              (r2 (coerce (aref res2 i) 'single-float)))
          (when (/= r1 r2)
            (format t "No. ~d was different!" i)
            (setf test nil)
            (return-from check)))))
    test))


(defun drotate-test (n)
  (declare (type integer n))
  (let* ((va (make-array n :element-type 'double-float))
         (vb (make-array n :element-type 'double-float))
         (theta (coerce (random (* 2d0 pi)) 'double-float))
         (c (cos theta))
         (s (sin theta))
         (res1c (make-array n :element-type 'double-float))
         (res1d (make-array n :element-type 'double-float))
         (res2c (make-array n :element-type 'double-float))
         (res2d (make-array n :element-type 'double-float))
         (test t))
    (declare (type (simple-array double-float (*)) va vb res1c res1d res2c res2d)
             (type double-float theta)
             (type (double-float -1d0 1d0) c s)
             (type boolean test))
    (dotimes (i n)
      (setf (aref va i) (random 1d0))
      (setf (aref vb i) (random 1d0)))
    (block check
      (drotate va vb c s res1c res1d)
      (drotate-naive va vb c s res2c res2d)
      (dotimes (i n)
        (let ((r1c (coerce (aref res1c i) 'single-float))
              (r1d (coerce (aref res1d i) 'single-float))
              (r2c (coerce (aref res2c i) 'single-float))
              (r2d (coerce (aref res2d i) 'single-float)))
          (when (or (/= r1c r2c) (/= r1d r2d))
            (format t "No. ~d was different!" i)
            (setf test nil)
            (return-from check)))))
    test))


(defun dm*v-test (n)
  (declare (type integer n))
  (let ((ma (make-array (list n n) :element-type 'double-float))
        (vb (make-array n :element-type 'double-float))
        (res1 (make-array n :element-type 'double-float))
        (res2 (make-array n :element-type 'double-float))
        (test t))
    (declare (type (simple-array double-float (* *)) ma)
             (type (simple-array double-float (*)) vb res1 res2)
             (type boolean test))
    (dotimes (i n)
      (dotimes (j n)
        (setf (aref ma i j) (random 1d0)))
      (setf (aref vb i) (random 1d0)))
    (block check
      (dm*v ma vb res1)
      (dm*v-naive ma vb res2)
      (dotimes (i n)
        (let ((r1 (coerce (aref res1 i) 'single-float))
              (r2 (coerce (aref res2 i) 'single-float)))
          (when (/= r1 r2)
            (format t "No. ~d was different!" i)
            (setf test nil)
            (return-from check)))))
    test))


(defun dm*m-test (n)
  (declare (type integer n))
  (let ((ma (make-array (list n n) :element-type 'double-float))
        (mb (make-array (list n n) :element-type 'double-float))
        (res1 (make-array (list n n) :element-type 'double-float))
        (res2 (make-array (list n n) :element-type 'double-float))
        (test t))
    (declare (type (simple-array double-float (* *)) ma mb res1 res2)
             (type boolean test))
    (dotimes (i n)
      (dotimes (j n)
        (setf (aref ma i j) (random 1d0))
        (setf (aref mb i j) (random 1d0))))
    (block check
      (dm*m ma mb res1)
      (dm*m-naive ma mb res2)
      (dotimes (i n)
        (dotimes (j n)
          (let ((r1 (coerce (aref res1 i j) 'single-float))
                (r2 (coerce (aref res2 i j) 'single-float)))
            (when (/= r1 r2)
              (format t "No. (~d, ~d) was different!" i j)
              (setf test nil)
              (return-from check))))))
    test))


(plan 6)
(ok (ddotprod-test 5000))
(ok (dnorm-test 5000))
(ok (dadd-test 5000))
(ok (drotate-test 5000))
(ok (dm*v-test 500))
(ok (dm*m-test 50))
(finalize)
