(in-package :cl-user)
(defpackage cl3a-test
  (:use :cl :prove :cl3a :naive-funcs :alexandria))
(in-package #:cl3a-test)


(plan 4)


(defun ddotprod-test (n)
  (declare (type integer n))
  (let ((va (make-array (list n) :element-type 'double-float))
        (vb (make-array (list n) :element-type 'double-float)))
    (declare (type (simple-array double-float (*)) va vb))
    (dotimes (i n)
      (setf (aref va i) (random 1d0))
      (setf (aref vb i) (random 1d0)))
    (let ((res1 (coerce (cl3a:dv*v va vb) 'single-float))
          (res2 (coerce (naive:dv*v va vb) 'single-float)))
      (declare (type single-float res1 res2))
      (= res1 res2))))
(ok (ddotprod-test 5000))


(defun dnorm-test (n)
  (declare (type integer n))
  (let ((va (make-array (list n) :element-type 'double-float)))
    (declare (type (simple-array double-float (*)) va))
    (dotimes (i n)
      (setf (aref va i) (random 1d0)))
    (let ((res1 (coerce (cl3a:dnorm va) 'single-float))
          (res2 (coerce (naive:dnorm va) 'single-float)))
      (declare (type single-float res1 res2))
      (= res1 res2))))
(ok (dnorm-test 5000))


(defun dadd-test (n)
  (declare (type integer n))
  (let ((va (make-array (list n) :element-type 'double-float))
        (vb (make-array (list n) :element-type 'double-float))
        (a (random 1d0))
        (b (random 1d0))
        (test t))
    (declare (type (simple-array double-float (*)) va vb)
             (type double-float a b)
             (type boolean test))
    (dotimes (i n)
      (setf (aref va i) (random 1d0))
      (setf (aref vb i) (random 1d0)))
    (let ((res1 (cl3a:dv+v a va b vb))
          (res2 (naive:dv+v a va b vb)))
      (declare (type (simple-array double-float (*)) res1 res2))
      (dotimes (i n)
        (let ((r1 (coerce (aref res1 i) 'single-float))
              (r2 (coerce (aref res2 i) 'single-float)))
          (when (= r1 r2)
            (setf test (and test t))))))
    test))
(ok (dadd-test 5000))


(defun drotate-test (n)
  (declare (type integer n))
  (let* ((va (make-array (list n) :element-type 'double-float))
         (vb (make-array (list n) :element-type 'double-float))
         (theta (coerce (random (* 2d0 pi)) 'double-float))
         (c (cos theta))
         (s (sin theta))
         (test t))
    (declare (type (simple-array double-float (*)) va vb)
             (type double-float theta)
             (type (double-float -1d0 1d0) c s)
             (type boolean test))
    (dotimes (i n)
      (setf (aref va i) (random 1d0))
      (setf (aref vb i) (random 1d0)))
    (multiple-value-bind (res1c res1d) (cl3a:drotate va vb c s)
      (declare (type (simple-array double-float (*)) res1c res1d))
      (multiple-value-bind (res2c res2d) (naive:drotate va vb c s)
        (declare (type (simple-array double-float (*)) res2c res2d))
        (dotimes (i n)
          (let ((r1c (coerce (aref res1c i) 'single-float))
                (r1d (coerce (aref res1d i) 'single-float))
                (r2c (coerce (aref res2c i) 'single-float))
                (r2d (coerce (aref res2d i) 'single-float)))
            (when (and (= r1c r2c) (= r1d r2d))
              (setf test (and test t)))))))
    test))
(ok (drotate-test 5000))

(finalize)
